try:
    import constants
except:
    from . import constants

import numpy as np
import pandas as pd

def get_fname(file_props: dict) -> str: 
    return f"hden{file_props['log_hden']:.5f}_metallicity{file_props['log_metallicity']:.5f}_turbulence{file_props['log_turbulence']:.5f}_isrf{file_props['log_isrf']:.5f}_radius{file_props['log_radius']:.5f}"

def find_converged_run(cloudy_em_str: np.ndarray, threshold: float = 0) -> np.ndarray:
    """
    To use the coverged value, I will look at the radius values in the file. If radius decreases to initial radius and simulations
    ran one more time starting from the beginning then it means that in the first run it is not coverged and simulation was run again
    Second run gives the converged value. Use the second run.
    """

    index = 0
    for i in range(len(cloudy_em_str) - 1):
        if (cloudy_em_str[i][0] - cloudy_em_str[i + 1][0]) > threshold:
            index = i + 1

    cloudy_em_str = cloudy_em_str[index:]

    return cloudy_em_str


def read_emissivity_file(base_dir, file_props):
    
    """
    Usage: 
    file_props = {
        "log_hden": 2,
        "log_metallicity": 0.5,
        "log_turbulence": 1,
        "log_isrf": 2,
        "log_radius": 1
    }
    cloudy_em_str = read_emissivity_file(base_dir, file_props)

    Reads the emissivity file generated by Cloudy simulations.
    The file is expected to be in the format:
    hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}/hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}_em.str

    Returns a pandas DataFrame with the emissivity data.
    The DataFrame contains the following columns:
    - depth: depth in the simulation (cm)
    - lya: Lyman-alpha emissivity (erg/cm^3/s)
    ... other emission lines as defined in emissivity_columns
    - column_density: column density calculated from depth and log_hden

    """

    emissivity_columns = [
        "depth",
        "lya",    # [erg/cm3/s]
        "ha",
        "hb",
        "co_10",
        "co_21",
        "co_32",
        "co_43",
        "co_54",
        "co_65",
        "co_76",
        "co_87",
        "13co",
        "c2",
        "o3_88", 
        "o3_5006", 
        "o3_4958",    
    ]    
    
    fname = get_fname(file_props = file_props)
    file_path = f"{base_dir}/{fname}/{fname}_em.str"
    print(f"Reading: {file_path}")
    
    emissivity_file = np.loadtxt(file_path)
    emissivity_file = find_converged_run(emissivity_file)
    emissivity_file = pd.DataFrame(emissivity_file, columns=emissivity_columns)
    emissivity_file['column_density'] = emissivity_file['depth'] * (10**file_props['log_hden'] * constants.proton_mass * constants.kg2g) # g / cm2    
    
    return emissivity_file


def read_emissivity_file_with_file_path(file_path):
    
    """
    Usage: 
    Reads the emissivity file generated by Cloudy simulations.
    The file is expected to be in the format:
    hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}/hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}_em.str

    Returns a pandas DataFrame with the emissivity data.
    The DataFrame contains the following columns:
    - depth: depth in the simulation (cm)
    - lya: Lyman-alpha emissivity (erg/cm^3/s)
    ... other emission lines as defined in emissivity_columns
    - column_density: column density calculated from depth and log_hden

    """

    emissivity_columns = [
        "depth",
        "lya",    # [erg/cm3/s]
        "ha",
        "hb",
        "co_10",
        "co_21",
        "co_32",
        "co_43",
        "co_54",
        "co_65",
        "co_76",
        "co_87",
        "13co",
        "c2",
        "o3_88", 
        "o3_5006", 
        "o3_4958",    
    ]    
    
    emissivity_file = np.loadtxt(file_path)
    emissivity_file = find_converged_run(emissivity_file)
    emissivity_file = pd.DataFrame(emissivity_file, columns=emissivity_columns)
    
    return emissivity_file



def read_emissivity_file2(path2file:str) -> pd.DataFrame:
    
    """
    Reads the emissivity file generated by Cloudy simulations.

    Returns a pandas DataFrame with the emissivity data.
    The DataFrame contains the following columns:
    - depth: depth in the simulation (cm)
    - lya: Lyman-alpha emissivity (erg/cm^3/s)
    ... other emission lines as defined in emissivity_columns
    - column_density: column density calculated from depth and log_hden

    """

    emissivity_columns = [
        "depth",
        "lya",    # [erg/cm3/s]
        "ha",
        "hb",
        "co_10",
        "co_21",
        "co_32",
        "co_43",
        "co_54",
        "co_65",
        "co_76",
        "co_87",
        "13co",
        "c1_607",
        "c1_370",
        "c2",
        "o1_6300",
        "o3_88", 
        "o3_5006", 
        "o3_4958",
        "hcn_3381_44",
        "hcn_3381_58",
        "hcn_3381_52",
        "hco+",    
    ]    
    file_path = path2file
    emissivity_file = np.loadtxt(file_path)
    emissivity_file = find_converged_run(emissivity_file)
    emissivity_file = pd.DataFrame(emissivity_file, columns=emissivity_columns)
    
    return emissivity_file

def read_ovr_file(base_dir, file_props):

    """
    Usage:
    file_props = {
        "log_hden": 2,
        "log_metallicity": 0.5,
        "log_turbulence": 1,
        "log_isrf": 2,
        "log_radius": 1
    }
    ovr_file = read_ovr_file(base_dir, file_props)

    Reads the ovr file generated by Cloudy simulations.
    The file is expected to be in the format:
    hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}/hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}.ovr

    Returns a pandas DataFrame with the ovr data.
    The DataFrame contains the following columns:
    - depth: depth in the simulation (cm)
    - Te: electron temperature (K)
    - Htot: total hydrogen density (cm^-3)
    - hden: hydrogen density (cm^-3)
    - eden: electron density (cm^-3)
    - 2H_2/H: molecular hydrogen fraction
    - HI, HII, HeI, HeII, HeIII: ionization fractions of hydrogen and helium
    - CO/C, C1, C2, C3, C4: carbon species
    - O1, O2, O3, O4, O5, O6: oxygen species
    - H2O/O: water to oxygen ratio
    - AV(point), AV(extend): visual extinction for point and extended sources
    - Tau912: optical depth at 912 Angstroms
    - column_density: column density calculated from depth and log_hden
    """

    # Build file name from properties
    file_name = get_fname(file_props)
    file_path = f"{base_dir}/{file_name}/{file_name}.ovr"
    print(f"Reading: {file_path}")

    # Read the file with the header from the first row
    ovr_file = pd.read_csv(
        file_path,
        sep=r"\s+",    # whitespace separated
        header=0       # first row is header
    )

    # Clean the first column name if it starts with '#'
    ovr_file.columns = [
        col.lstrip('#') if isinstance(col, str) else col
        for col in ovr_file.columns
    ]

    # Calculate column density
    ovr_file['column_density'] = (
        ovr_file['depth'] *
        (10**file_props['log_hden'] * constants.proton_mass * constants.kg2g)
    )  # g / cm2


    # If you want to compute column density:
    # ovr_file['column_density'] = (
    #     ovr_file['depth'] *
    #     (10**file_props['log_hden'] * constants.proton_mass * constants.kg2g)
    # )


    return ovr_file 



def read_ovr_file_2(path2file: str) -> pd.DataFrame:

    """
    ovr_file = read_ovr_file(path2file)

    Reads the ovr file generated by Cloudy simulations.
    The file is expected to be in the format:

    Returns a pandas DataFrame with the ovr data.
    The DataFrame contains the following columns:
    - depth: depth in the simulation (cm)
    - Te: electron temperature (K)
    - Htot: total hydrogen density (cm^-3)
    - hden: hydrogen density (cm^-3)
    - eden: electron density (cm^-3)
    - 2H_2/H: molecular hydrogen fraction
    - HI, HII, HeI, HeII, HeIII: ionization fractions of hydrogen and helium
    - CO/C, C1, C2, C3, C4: carbon species
    - O1, O2, O3, O4, O5, O6: oxygen species
    - H2O/O: water to oxygen ratio
    - AV(point), AV(extend): visual extinction for point and extended sources
    - Tau912: optical depth at 912 Angstroms
    - column_density: column density calculated from depth and log_hden
    """


    # Read the file with the header from the first row
    ovr_file = pd.read_csv(
        path2file,
        sep=r"\s+",    # whitespace separated
        header=0       # first row is header
    )

    # Clean the first column name if it starts with '#'
    ovr_file.columns = [
        col.lstrip('#') if isinstance(col, str) else col
        for col in ovr_file.columns
    ]

    return ovr_file 

def read_calculations_for_all_cloudy_runs(base_dir: str) -> None:

    file_names = {
        "flux": "F_line_values_without_reversing.csv",
        "abundance": "other_properties_sigma_all_slab_not_averaged.csv",
        "temperature": "temperatures.csv",
    }

    data = pd.DataFrame()
    # Read the files
    for key, file_name in file_names.items():
        file_path = f"{base_dir}/{file_name}"
        try:
            df = pd.read_csv(file_path)

            # Merge on ['log_metallicity', 'log_hden', 'log_turbulence', 'log_isrf']
            if data.empty:
                data = df
            else:
                data = pd.merge(data, df, on=['log_metallicity', 'log_hden', 'log_turbulence', 'log_isrf', 'log_radius'], how='outer', validate="one_to_one")
        except FileNotFoundError:
            print(f"File {file_path} not found.")
            continue


    return data 




def read_continuum_file(base_dir: str, file_props: dict) -> pd.DataFrame:
    """
    Reads the continuum file generated by Cloudy simulations.
    The file is expected to be in the format:
    hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}/hden{log_hden}_metallicity{log_metallicity}_turbulence{log_turbulence}_isrf{log_isrf}_radius{log_radius}_cont.out

    Returns a pandas DataFrame with the continuum data.
    """

    continuum_columns = [
        "lambda", # I used save continuum last ".con" units microns. So it is in microns
        "incident",
        "trans",
        "DiffOut",
        "net",
        "trans",
        "reflc",
        "total",
        # "reflin",
        # "outlin",
        # "lineID",
        # "cont",
        # "nLine",
    ]    
    
    fname = get_fname(file_props = file_props)
    file_path = f"{base_dir}/{fname}/{fname}.con"
    print(f"Reading: {file_path}")
    
    continuum_file = np.loadtxt(file_path, usecols=range(len(continuum_columns)))
    continuum_file = pd.DataFrame(continuum_file, columns=continuum_columns)

    return continuum_file


if __name__ == "__main__":

    log_hden = 2  # 1/cm3
    log_metallicity = 0.5  # Zsolar
    log_turbulence = 1  # km/s
    log_radius = 2  # pc    

    file_props = {
        "log_hden": log_hden, # 1/cm3
        "log_metallicity": log_metallicity, # Zsolar
        "log_turbulence": log_turbulence, # km/s
        "log_isrf": -1, # G0
        "log_radius": log_radius # pc
    }


    base_dir = "/scratch/dtolgay/cloudy_runs/z_0/cr_1_CO87_CII_H_O3/cr_1_CO87_CII_H_O3_metallicity_above_minus_2"


    read_continuum_file(base_dir = base_dir, file_props = file_props)

    # read_calculations_for_all_cloudy_runs(base_dir)
    